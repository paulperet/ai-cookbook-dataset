##### Copyright 2025 Google LLC.


```
# @title Licensed under the Apache License, Version 2.0 (the "License");
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
```

# Gemini API: Code Execution

The Gemini API [code execution](https://ai.google.dev/gemini-api/docs/code-execution) feature enables the model to generate and run Python code based on plain-text instructions that you give it, and even output graphs. It can learn iteratively from the results until it arrives at a final output.

This notebook is a walk through:
* Understanding how to start using the code execution feature with Gemini API
* Learning how to use code execution on single Gemini API calls
* Running scenarios using local files (or files uploaded to the Gemini File API) via File I/O
* Using code execution on chat interactions
* Performing code execution on multimodal scenarios

## Setup

### Install SDK

Install the SDK from [PyPI](https://github.com/googleapis/python-genai).


```
%pip install -q -U "google-genai>=1.0.0"
```

### Setup your API key

To run the following cell, your API key must be stored it in a Colab Secret named `GOOGLE_API_KEY`. If you don't already have an API key, or you're not sure how to create a Colab Secret, see [Authentication](../quickstarts/Authentication.ipynb) for an example.


```
from google.colab import userdata

GOOGLE_API_KEY = userdata.get('GOOGLE_API_KEY')
```

### Initialize SDK client

With the new SDK you now only need to initialize a client with you API key (or OAuth if using [Vertex AI](https://cloud.google.com/vertex-ai)). The model is now set in each call.


```
from google import genai

client = genai.Client(api_key=GOOGLE_API_KEY)
```

### Choose a model

Now select the model you want to use in this guide, either by selecting one in the list or writing it down. Keep in mind that some models, like the 2.5 ones are thinking models and thus take slightly more time to respond (cf. [thinking notebook](./Get_started_thinking.ipynb) for more details and in particular learn how to switch the thiking off).

For more information about all Gemini models, check the [documentation](https://ai.google.dev/gemini-api/docs/models/gemini) for extended information on each of them.


```
MODEL_ID = "gemini-3-flash-preview" # @param ["gemini-2.5-flash-lite", "gemini-2.5-flash", "gemini-2.5-pro", "gemini-2.5-flash-preview", "gemini-3-pro-preview"] {"allow-input":true, isTemplate: true}
```

## Helper function

When using code execution as a tool, the model returns a list of parts including `text`, `executable_code`, `execution_result`, and `inline_data` parts. Use the function below to help you visualize and better display the code execution results. Here are a few details about the different fields of the results:

* `text`: Inline text generated by the model.
* `executable_code`: Code generated by the model that is meant to be executed.
* `code_execution_result`: Result of the `executable_code`.
* `inline_data`: Inline media generated by the model.


```
from IPython.display import Image, Markdown, Code, HTML

def display_code_execution_result(response):
  for part in response.candidates[0].content.parts:
    if part.text is not None:
      display(Markdown(part.text))
    if part.executable_code is not None:
      code_html = f'<pre style="background-color: green;">{part.executable_code.code}</pre>' # Change code color
      display(HTML(code_html))
    if part.code_execution_result is not None:
      display(Markdown(part.code_execution_result.output))
    if part.inline_data is not None:
      display(Image(data=part.inline_data.data, width=800, format="png"))
    display(Markdown("---"))
```

## Use `code_execution` with a single call

When initiating the model, pass `code_execution` as a `tool` to tell the model that it is allowed to generate and run code.


```
from google.genai import types

prompt = """
    What is the sum of the first 50 prime numbers?
    Generate and run code for the calculation, and make sure you get all 50.
"""

response = client.models.generate_content(
    model=MODEL_ID,
    contents=prompt,
    config=types.GenerateContentConfig(
        tools=[types.Tool(
            code_execution=types.ToolCodeExecution
            )]
        )
    )

display_code_execution_result(response)
```


Okay, I can help you with that. I will write and execute a Python script to find the first 50 prime numbers and calculate their sum.

Here is the plan:
1. Implement a function to check if a number is prime.
2. Iterate through numbers starting from 2, adding prime numbers to a list until we have 50.
3. Calculate the sum of the numbers in the list.
4. Print the sum.





---



<pre style="background-color: green;">import math

def is_prime(n):
    """Checks if a number n is prime."""
    if n < 2:
        return False
    # Check for divisibility from 2 up to the square root of n
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True

primes = []
num = 2 # Start checking from the first possible prime number

# Find the first 50 prime numbers
while len(primes) < 50:
    if is_prime(num):
        primes.append(num)
    num += 1

# Calculate the sum of the first 50 prime numbers
sum_of_primes = sum(primes)

print(f"The first 50 prime numbers are: {primes}")
print(f"The sum of the first 50 prime numbers is: {sum_of_primes}")
</pre>



---



The first 50 prime numbers are: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229]
The sum of the first 50 prime numbers is: 5117




---



The first 50 prime numbers have been identified and their sum calculated using the Python script.

The first 50 prime numbers are:
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229]

The sum of these numbers is: 5117.



---


## Code execution with File I/O

The dataset you will use in this guide comes from the [StatLib](http://lib.stat.cmu.edu/datasets/) from the [Department of Statistics](https://www.cmu.edu/dietrich/statistics-datascience/index.html) at [Carnegie Mellon University](http://www.cmu.edu/). It is made available by the [`scikit-learn`](https://scikit-learn.org) under the 3-Clause BSD license.

It provides 20k information on various blocks in Californina, including the location (longitute/lattitude), average income,
housing average age, average rooms, average bedrooms, population,
average occupation.

Here's a breakdown of the columns and what the attributes represent:
* MedInc:        median income in block group
* HouseAge:      median house age in block group
* AveRooms:      average number of rooms per household
* AveBedrms:     average number of bedrooms per household
* Population:    block group population
* AveOccup:      average number of household members
* Latitude:      block group latitude
* Longitude:     block group longitude

**Note**: Code execution functionality works best with a `.csv` or `.txt` file.



```
import pandas as pd
from sklearn.datasets import fetch_california_housing

california_housing = fetch_california_housing(as_frame=True)
california_housing.frame.to_csv('houses.csv', index=False)
```


```
# Read the CSV file into a pandas DataFrame
houses_data = pd.read_csv('houses.csv', nrows=5000) # only keeping the first 5000 entries to keep the request light (still 500k tokens). Use pro models to ingest the full dataset.
houses_data.to_csv('houses.csv', index=False)
houses_data.head()
```





| MedInc   | HouseAge   | AveRooms   | AveBedrms   | Population   | AveOccup   | Latitude   | Longitude   | MedHouseVal   |
|:---------|:-----------|:-----------|:------------|:-------------|:-----------|:-----------|:------------|:--------------|
| 8.3252   | 41         | 6.98413    | 1.02381     | 322          | 2.55556    | 37.88      | -122.23     | 4.526         |
| 8.3014   | 21         | 6.23814    | 0.97188     | 2401         | 2.10984    | 37.86      | -122.22     | 3.585         |
| 7.2574   | 52         | 8.28814    | 1.07345     | 496          | 2.80226    | 37.85      | -122.24     | 3.521         |
| 5.6431   | 52         | 5.81735    | 1.07306     | 558          | 2.54795    | 37.85      | -122.25     | 3.413         |
| 3.8462   | 52         | 6.28185    | 1.08108     | 565          | 2.18147    | 37.85      | -122.25     | 3.422         |





```
# Upload diving_data.csv file using the File API
houses_file = client.files.upload(
    file='houses.csv',
    config=types.FileDict(display_name='Blocks Data')
)

print(f"Uploaded file '{houses_file.display_name}' as: {houses_file.uri}")
```

    Uploaded file 'Blocks Data' as: https://generativelanguage.googleapis.com/v1beta/files/zncz5ziqcwxu


Let's try several queries about the dataset that you have. Starting off, it would be interesting to see the most expensive blocks and check wether there's abnomal data.


```
response = client.models.generate_content(
    model=MODEL_ID,
    contents=[
        "This dataset provides information on various blocks in Californina.",
        "Generate a scatterplot comparing the houses age with the median house value for the top-20 most expensive blocks.",
        "Use each black as a different color, and include a legend of what each color represents.",
        "Plot the age as the x-axis, and the median house value as the y-axis.",
        "In addition, point out on the graph which points could be anomalies? Circle the anomaly in red on the graph."
        "Then save the plot as an image file and display the image.",
        houses_file
    ],
    config=types.GenerateContentConfig(
        tools=[types.Tool(code_execution=types.ToolCodeExecution)]
    )
)

display_code_execution_result(response)
```


<pre style="background-color: green;">import pandas as pd

# Load the CSV file
try:
    df = pd.read_csv('input_file_0.csv')
    print("File loaded successfully.")
    # Print the column names and the first few rows to understand the data
    print("Column names:", df.columns.tolist())
    print("\nFirst 5 rows of the dataframe:")
    print(df.head().to_markdown(index=False, numalign="left", stralign="left"))
except FileNotFoundError:
    print("Error: input_file_0.csv not found.")
except Exception as e:
    print(f"An error occurred while loading the file: {e}")</pre>



---



File loaded successfully.
Column names: ['MedInc', 'HouseAge', 'AveRooms', 'AveBedrms', 'Population', 'AveOccup', 'Latitude', 'Longitude', 'MedHouseVal']

First 5 rows of the dataframe:
| MedInc   | HouseAge   | AveRooms   | AveBedrms   | Population   | AveOccup   | Latitude   | Longitude   | MedHouseVal   |
|:---------|:-----------|:-----------|:------------|:-------------|:-----------|:-----------|:------------|:--------------|
| 8.3252   | 41         | 6.98413    | 1.02381     | 322          | 2.55556    | 37.88      | -122.23     | 4.526         |
| 8.3014   | 21         | 6.23814    | 0.97188     | 2401         | 2.10984    | 37.86      | -122.22     | 3.585         |
| 7.2574   | 52         | 8.28814    | 1.07345     | 496          | 2.80226    | 37.85      | -122.24     | 3.521         |
| 5.6431   | 52         | 5.81735    | 1.07306     | 558          | 2.54795    | 37.85      | -122.25     | 3.413         |
| 3.8462   | 52         | 6.28185    | 1.08108     | 565          | 2.18147    | 37.85      | -122.25     | 3.422         |




---



<pre style="background-color: green;">import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Load the CSV file (already loaded in the previous step, but repeating for clarity in this block)
df = pd.read_csv('input_file_0.csv')

# Sort by 'MedHouseVal' in descending order and select the top 20
top_20_blocks = df.nlargest(20, 'MedHouseVal').reset_index()
top_20_blocks['Block_ID'] = top_20_blocks.index # Add a unique identifier for each block

print("\nTop 20 most expensive blocks:")
print(top_20_blocks[['HouseAge', 'MedHouseVal', 'Block_ID']].to_markdown(index=False, numalign="left", stralign="left"))

# Prepare data for plotting - treating each block as a separate series for unique colors
ages = top_20_blocks['HouseAge']
values = top_20_blocks['MedHouseVal']
block_ids = top_20_blocks['Block_ID']

# Define a color map for 20 unique colors
colors = plt.cm.get_cmap('tab20', 20)

# Create the scatterplot
plt.figure(figsize=(12, 8))

scatter_elements = []
for i in range(len(top_20_blocks)):
    sc = plt.scatter(ages.iloc[i], values.iloc[i], color=colors(i), label=f'Block {block_ids.iloc[i]}')
    scatter_elements.append(sc)

plt.xlabel('House Age')
plt.ylabel('Median House Value')
plt.title('House Age vs. Median House Value for Top 20 Most Expensive Blocks')

# Add legend. The legend will be large, but fulfilling the request.
# Position the legend outside the plot area
plt.legend(handles=scatter_elements, title="Block ID", bbox_to_anchor=(1.05, 1), loc='upper left', borderaxesPad=0.)

plt.grid(True)
plt.tight_layout() # Adjust layout to prevent legend overlapping plot

# Anomaly detection - visual inspection of the plotted points.
# Let's examine the data points. We are looking for points that are significantly different from the others.
# For example, a very young house with a very high value, or a very old house with a relatively low value compared to others in this high-value group.
# Looking at the printed table:
# Row 0: HouseAge 41, MedHouseVal 4.526
# ...
# Row 64: HouseAge 52, MedHouseVal 5.00001 (This is a ceiling value)
# Row 65: HouseAge 39, MedHouseVal 5.00001 (Ceiling value)
# Row 66: HouseAge 42, MedHouseVal 5.00001 (Ceiling value)
# Row 67: HouseAge 52, MedHouseVal 5.00001 (Ceiling value)
# Row 68: HouseAge 52, MedHouseVal 4.661
# Row 69: HouseAge 52, MedHouseVal 5.00001 (Ceiling value)
# Row 70: HouseAge 52, MedHouseVal 4.578
# Row 71: HouseAge 52